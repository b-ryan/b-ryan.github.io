<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>buckryan.com</title><link href="http://buckryan.com/" rel="alternate"></link><link href="http://buckryan.com/feeds/buck-ryan.atom.xml" rel="self"></link><id>http://buckryan.com/</id><updated>2015-01-02T00:00:00-05:00</updated><entry><title>Organizing photos with bash</title><link href="http://buckryan.com/organizing-photos-with-bash.html" rel="alternate"></link><updated>2015-01-02T00:00:00-05:00</updated><author><name>Buck Ryan</name></author><id>tag:buckryan.com,2015-01-02:organizing-photos-with-bash.html</id><summary type="html">&lt;p&gt;I've been trying to organize my photos recently. I hadn't kept up with them
and I recently discovered I have a pile of photos dumped into a single
directory. I like to separate photos by the day they were taken so I end up
with directories like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;2015-01-01_new-years-day
2014-12-31_new-years-eve
2014-12-25_christmas
...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Wanting to organize these as painlessly as I could think, I sought to run a few
bash commands to split my pile of photos into directories like these. The first
issue I ran into was the file formats - these were raw photos. I had found a
nice tool called &lt;code&gt;exif&lt;/code&gt; (&lt;code&gt;sudo apt-get install exif&lt;/code&gt;) which I could use to
extract the date the pictures were taken, but it only works on JPG images.&lt;/p&gt;
&lt;p&gt;So step one was to convert the files. The
&lt;a href="http://imagemagick.org/"&gt;ImageMagick&lt;/a&gt; tool (&lt;code&gt;sudo apt-get install
imagemagick&lt;/code&gt;) has a command called &lt;code&gt;convert&lt;/code&gt; that will do just that. To convert
them all without risking overwriting anything, a simple for loop works nicely:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; f in *.NEF&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    convert &lt;span class="nv"&gt;$f&lt;/span&gt; &lt;span class="nv"&gt;$f&lt;/span&gt;.jpg
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This will convert files like &lt;code&gt;DSC_0001.NEF&lt;/code&gt; to &lt;code&gt;DSC_0001.NEF.jpg&lt;/code&gt;. Running this
command was taking awhile and I wanted to see how much work was left to do.
&lt;code&gt;watch&lt;/code&gt; is the perfect tool for the job. It lets you repeatedly run a command
and see its output. So all I needed to do was write a command that would list
all of the &lt;code&gt;.NEF&lt;/code&gt; files that did not have corresponding &lt;code&gt;.NEF.jpg&lt;/code&gt; files.  To
do that, I used:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; f in *.NEF&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    ls &lt;span class="nv"&gt;$f&lt;/span&gt;.jpg &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&amp;gt;/dev/null &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$f&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I ignored all output of &lt;code&gt;ls&lt;/code&gt; (&lt;code&gt;&amp;amp;&amp;gt;/dev/null&lt;/code&gt;) because the return code would be
enough to determine whether the file existed. More importantly, I didn't want
to have to parse through whatever output the command threw at me. The &lt;code&gt;|| echo
$f&lt;/code&gt; will only be executed if the &lt;code&gt;ls&lt;/code&gt; failed, indicating the file doesn't
exist.&lt;/p&gt;
&lt;p&gt;I had issues running this directly with &lt;code&gt;watch&lt;/code&gt;, but I didn't want to spend
time debugging. Instead I saved the command to a file and ran:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod +x script.sh
watch ./script.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Every 2 seconds the screen updated letting me know how many files were left
to convert.&lt;/p&gt;
&lt;p&gt;While the conversion was running, I prepared to get exif data out of the jpg
files. I mentioned above that &lt;code&gt;exif&lt;/code&gt; will do just that. Here's what a sample
run looked like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  $ exif DSC_0093.JPG 
EXIF tags in &amp;#39;DSC_0093.JPG&amp;#39; (&amp;#39;Motorola&amp;#39; byte order):
--------------------+----------------------------------------------------------
Tag                 |Value
--------------------+----------------------------------------------------------
Manufacturer        |
Model               |
X-Resolution        |500.0000000
Y-Resolution        |500.0000000
Resolution Unit     |Inch
Software            |Picasa 3.0
Date and Time       |2007:04:09 16:15:47
YCbCr Positioning   |Centered
Padding             |2060 bytes undefined data
Compression         |JPEG compression
X-Resolution        |72
Y-Resolution        |72
Resolution Unit     |Inch
Exif Version        |Exif Version 2.2
Date and Time (Origi|2007:12:25 11:07:52
Date and Time (Digit|2007:12:25 11:07:52
Components Configura|Y Cb Cr -
User Comment        |
Sub-second Time (Ori|00
Sub-second Time (Dig|00
FlashPixVersion     |FlashPix Version 1.0
Color Space         |Internal error (unknown value 65535)
Pixel X Dimension   |3008
Pixel Y Dimension   |2000
Custom Rendered     |Custom process
Image Unique ID     |517d7ada5c38d78cd60a3032343e64f1
Padding             |2060 bytes undefined data
Interoperability Ver|0100
--------------------+----------------------------------------------------------
EXIF data contains a thumbnail (5597 bytes).
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(This was a &lt;em&gt;really&lt;/em&gt; old photo - most of them were much more recent.)&lt;/p&gt;
&lt;p&gt;I noticed there was the &lt;code&gt;Date and Time&lt;/code&gt; tag in there. And in reading the man
page for &lt;code&gt;exif&lt;/code&gt;, saw that I could ask for values of specific tags using the
&lt;code&gt;--tag&lt;/code&gt; argument. Here is what happened for the same file above:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  $ exif --tag &amp;#39;Date and Time&amp;#39; DSC_0093.JPG 
EXIF entry &amp;#39;Date and Time&amp;#39; (0x132, &amp;#39;DateTime&amp;#39;) exists in IFD &amp;#39;0&amp;#39;:
Tag: 0x132 (&amp;#39;DateTime&amp;#39;)
  Format: 2 (&amp;#39;ASCII&amp;#39;)
  Components: 20
  Size: 20
  Value: 2007:04:09 16:15:47
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We can work with that! A few &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;awk&lt;/code&gt; commands later and I had:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  $ exif --tag &amp;#39;Date and Time&amp;#39; DSC_0093.JPG \
    | grep Value \
    | awk &amp;#39;{print $2}&amp;#39; \
    | awk -F&amp;#39;:&amp;#39; &amp;#39;{print $1 &amp;quot;-&amp;quot; $2 &amp;quot;-&amp;quot; $3}&amp;#39;
2007-04-09
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To break that down: &lt;code&gt;grep Value&lt;/code&gt; is pretty obvious. It will leave only the
line containing &lt;code&gt;Value&lt;/code&gt; so now our result will look like&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  Value: 2007:04:09 16:15:47
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then this gets piped to &lt;code&gt;awk '{print $2}'&lt;/code&gt;. This is a very common type of awk
command to run. Since awk splits on whitespace by default, this will get us
the second column, which in this case contains the text&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;2007&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;04&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I didn't care about the time of the photo since I'm planning to lump all of
the photos from the same day into a given directory. If I had wanted the date
&lt;em&gt;and&lt;/em&gt; time, I could have used &lt;code&gt;awk '{print $2 " " $3}'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that I have the date, I want it in my preferred format of &lt;code&gt;yyyy-mm-dd&lt;/code&gt; so
I once again turned to awk. This time I used &lt;code&gt;-F':'&lt;/code&gt; to specify that I wanted
to split on &lt;code&gt;:&lt;/code&gt; instead of whitespace. Then I rest of the command glues the
date, month, and year parts together with &lt;code&gt;-&lt;/code&gt; in between.&lt;/p&gt;
&lt;p&gt;So now I have to use all of this to make the directories and dump files into
them. Before actually creating any directories or moving any files, however,
I wanted to sanity check everything. I wrote a loop that spit out each of the
&lt;code&gt;*NEF.jpg&lt;/code&gt; files and the date I calculated for them:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; f in *NEF.jpg&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$f&lt;/span&gt;&lt;span class="s2"&gt; &amp;quot;&lt;/span&gt;
    &lt;span class="nv"&gt;dt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;exif --tag &lt;span class="s1"&gt;&amp;#39;Date and Time&amp;#39;&lt;/span&gt; &lt;span class="nv"&gt;$f&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
            &lt;span class="p"&gt;|&lt;/span&gt; grep Value &lt;span class="se"&gt;\&lt;/span&gt;
            &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
            &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;:&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1 &amp;quot;-&amp;quot; $2 &amp;quot;-&amp;quot; $3}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$dt&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;echo&lt;/code&gt; tells it to not print a newline. I then saved the
result of the command to calculate the picture's date to a variable called
&lt;code&gt;dt&lt;/code&gt; so that I could reuse it in the code to follow. Here's a snippet of the
results:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;DSC_1455.NEF.jpg    2014-07-28
DSC_1456.NEF.jpg    2014-07-28
DSC_1457.NEF.jpg    2014-07-28
DSC_1458.NEF.jpg    2014-07-28
DSC_1460.NEF.jpg    2014-07-28
DSC_1461.NEF.jpg    2014-07-28
DSC_1463.NEF.jpg    2014-07-28
DSC_1506.NEF.jpg    2014-09-03
DSC_1507.NEF.jpg    2014-09-03
DSC_1512.NEF.jpg    2014-09-03
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;After sanity checking the results, I felt confident enough to go forward. Here
is the final product:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; f in *NEF.jpg&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nv"&gt;dt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;exif --tag &lt;span class="s1"&gt;&amp;#39;Date and Time&amp;#39;&lt;/span&gt; &lt;span class="nv"&gt;$f&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
            &lt;span class="p"&gt;|&lt;/span&gt; grep Value &lt;span class="se"&gt;\&lt;/span&gt;
            &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{print $2}&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
            &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;:&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1 &amp;quot;-&amp;quot; $2 &amp;quot;-&amp;quot; $3}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

    mkdir &lt;span class="nv"&gt;$dt&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&amp;gt;/dev/null
    mv &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;f&lt;/span&gt;&lt;span class="p"&gt;%.jpg&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; &lt;span class="nv"&gt;$dt&lt;/span&gt;/
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The most interesting part of this code is the &lt;code&gt;${f%.jpg}&lt;/code&gt;. This chops &lt;code&gt;.jpg&lt;/code&gt;
off of the end of the string. To fully grasp what's going on, check out &lt;a href="http://tldp.org/LDP/abs/html/string-manipulation.html"&gt;this
article&lt;/a&gt;, specifically
the section titled &lt;strong&gt;Substring Removal&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;And that was it! Was a lot of faster than doing it by hand. Maybe there are
tools out there that could have done this for me, but I found this more fun.
You can really do some neat stuff with everyday command-line tools. I highly
recommend using them for tasks like this to become comfortable writing bash.&lt;/p&gt;</summary><category term="bash"></category></entry><entry><title>Manipulating Vim Registers</title><link href="http://buckryan.com/manipulating-vim-registers.html" rel="alternate"></link><updated>2014-11-02T00:00:00-04:00</updated><author><name>Buck Ryan</name></author><id>tag:buckryan.com,2014-11-02:manipulating-vim-registers.html</id><summary type="html">&lt;p&gt;Recently I came across PHP code that looked similar to this:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;const YEAR = 1;&lt;/span&gt;
&lt;span class="x"&gt;const QUARTER = 2;&lt;/span&gt;
&lt;span class="x"&gt;const MONTH = 3;&lt;/span&gt;
&lt;span class="x"&gt;const WEEK = 4;&lt;/span&gt;
&lt;span class="x"&gt;const DAY = 5;&lt;/span&gt;
&lt;span class="x"&gt;const HOUR = 6;&lt;/span&gt;
&lt;span class="x"&gt;const SECOND = 7;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;I wanted to write a switch statement which handled each of those constants.
This is what each case statement would look like:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;case self::YEAR:&lt;/span&gt;
&lt;span class="x"&gt;case self::QUARTER:&lt;/span&gt;
&lt;span class="x"&gt;case self::MONTH:&lt;/span&gt;
&lt;span class="x"&gt;case self::WEEK:&lt;/span&gt;
&lt;span class="x"&gt;case self::DAY:&lt;/span&gt;
&lt;span class="x"&gt;case self::HOUR:&lt;/span&gt;
&lt;span class="x"&gt;case self::SECOND:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;One way to achieve this would be to yank the whole text, paste it where the
switch will live, and with the help of a macro, change each line into a case
statement. &lt;a href="http://blog.sanctum.geek.nz/advanced-vim-macros/"&gt;This article&lt;/a&gt; is
a great reference for advanced macro techniques, any of which would be useful
if we took this approach. However, it's possible to be more succinct by
building up the case statements incrementally with the help of registers
(&lt;a href="http://vimdoc.sourceforge.net/htmldoc/change.html#registers"&gt;:help
registers&lt;/a&gt;). This
post will show a few ways to do that so that you can learn how to master
registers. Here are some examples to start us off:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Command&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:let @a = ""&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Clear out register "a"&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:let @a .= "I am register a!"&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Append the string "I am register a!" to register "a"&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:let @c = "b is: " . @b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Set register "c" to be the string "b is: " concatenated with register "b"&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:reg c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Check what's in register "c"&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"dyy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;Replace register "d" with the current line&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;"Dyy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;If you'd rather not overwrite register "d", but instead append to it&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;em&gt;For more details on the &lt;code&gt;:let @&lt;/code&gt; command, check out &lt;a href="http://vimdoc.sourceforge.net/htmldoc/eval.html#:let-@"&gt;:help
:let-@&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Knowing just the above will get us far. Let's see how we can apply them toward
making our case statements. Our first exercise is pretty simple. We will get
the contents of register &lt;code&gt;a&lt;/code&gt; to be:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;YEAR&lt;/span&gt;
&lt;span class="x"&gt;QUARTER&lt;/span&gt;
&lt;span class="x"&gt;MONTH&lt;/span&gt;
&lt;span class="x"&gt;WEEK&lt;/span&gt;
&lt;span class="x"&gt;DAY&lt;/span&gt;
&lt;span class="x"&gt;HOUR&lt;/span&gt;
&lt;span class="x"&gt;SECOND&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;em&gt;(note that there will actually be an empty first line)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Start by moving your cursor to the word "YEAR" and initializing register &lt;code&gt;a&lt;/code&gt; to
a newline:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;/YEAR&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; @&lt;span class="k"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Doing so will make register &lt;code&gt;a&lt;/code&gt; linewise (&lt;a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#linewise"&gt;:help
linewise&lt;/a&gt;). I
explain below why this happens and what effect is has, but for now, suffice it
to say that when you yank more text into &lt;code&gt;a&lt;/code&gt;, Vim will keep a newline at the
end of the register. Go ahead and yank the word "YEAR" onto the end of register
a to see it happen:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;&amp;quot;Aye&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As we saw above, &lt;code&gt;"A&lt;/code&gt; tells vim that the next thing we yank should be appended
to register &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;ye&lt;/code&gt; means to yank until the end of the word. Examine
register &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;:reg a&lt;/code&gt; to see it is set to&lt;code&gt;^JYEAR^J&lt;/code&gt; (&lt;code&gt;^J&lt;/code&gt; stands for the
newline character). Move your cursor down so it is on &lt;code&gt;QUARTER&lt;/code&gt; and again use
&lt;code&gt;"Aye&lt;/code&gt; to append onto &lt;code&gt;a&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt; is now &lt;code&gt;^JYEAR^JQUARTER^J&lt;/code&gt;. Do this for every
line (or even better, record a macro to automate it) and register &lt;code&gt;a&lt;/code&gt; will have
the text we were going for.&lt;/p&gt;
&lt;p&gt;That was a fun exercise, but to finish writing each case statement, we would
need to edit each line in register &lt;code&gt;a&lt;/code&gt;, which we wanted to avoid in the first
place. We can do better. As before, move your cursor to &lt;code&gt;YEAR&lt;/code&gt;, but this time
clear out register &lt;code&gt;a&lt;/code&gt; entirely:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;/YEAR&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; @&lt;span class="k"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;We will use another register to help us. Yank &lt;code&gt;YEAR&lt;/code&gt; into register &lt;code&gt;b&lt;/code&gt; and use
it to append to register &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;&amp;quot;bye&lt;/span&gt;
&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; @&lt;span class="k"&gt;a&lt;/span&gt; .&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;case self::&amp;quot;&lt;/span&gt; . @&lt;span class="k"&gt;b&lt;/span&gt; . &lt;span class="s2"&gt;&amp;quot;:\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This concatenates the text &lt;code&gt;case self::&lt;/code&gt; with the contents of register &lt;code&gt;b&lt;/code&gt; and
the string &lt;code&gt;:\n&lt;/code&gt;. Register &lt;code&gt;a&lt;/code&gt; is not linewise this time, so we have to append
the newline ourselves. &lt;code&gt;a&lt;/code&gt; will now be &lt;code&gt;case self::YEAR:^J&lt;/code&gt;. If we repeat the
above for each line (once again - use a macro!), register &lt;code&gt;a&lt;/code&gt; will be:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;case self::YEAR:&lt;/span&gt;
&lt;span class="x"&gt;case self::QUARTER:&lt;/span&gt;
&lt;span class="x"&gt;case self::MONTH:&lt;/span&gt;
&lt;span class="x"&gt;case self::WEEK:&lt;/span&gt;
&lt;span class="x"&gt;case self::DAY:&lt;/span&gt;
&lt;span class="x"&gt;case self::HOUR:&lt;/span&gt;
&lt;span class="x"&gt;case self::SECOND:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This is perfect. We eliminated the need to do any work after we pasted the
results. Instead, we just incrementally built the desired text within register
&lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can make one further improvement. Using register &lt;code&gt;b&lt;/code&gt; was an interesting way
of showing how you can use different registers and concatenate them together to
make the finished product. It's unnecessary, however, since we can use
&lt;code&gt;&amp;lt;C-R&amp;gt;&amp;lt;C-W&amp;gt;&lt;/code&gt; (&lt;a href="http://vimdoc.sourceforge.net/htmldoc/cmdline.html#c_CTRL-R_CTRL-W"&gt;:help
&amp;lt;c_CTRL-R_CTRL-W&gt;&lt;/a&gt;)
to insert the word under the cursor each time we append to &lt;code&gt;a&lt;/code&gt;. To demonstrate
this, again move to the beginning of &lt;code&gt;YEAR&lt;/code&gt; and clear register &lt;code&gt;a&lt;/code&gt;. This time,
skip yanking to register &lt;code&gt;b&lt;/code&gt; and do:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; @&lt;span class="k"&gt;a&lt;/span&gt; .&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;case self::&amp;lt;C-R&amp;gt;&amp;lt;C-W&amp;gt;:\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;After doing this for each line, register &lt;code&gt;a&lt;/code&gt; will be the same as before.&lt;/p&gt;
&lt;h1&gt;Linewise vs. characterwise registers&lt;/h1&gt;
&lt;p&gt;As I mentioned above, Vim will make a register &lt;code&gt;linewise&lt;/code&gt; when the expression
you assign using &lt;code&gt;:let @...&lt;/code&gt; ends in a newline. Vim will keep a newline at the
end of the register whenever you append to it by yanking, deleting, etc., but
not when you directly modify the register using &lt;code&gt;:let @...&lt;/code&gt;. Even if you
already have something in the register and append using &lt;code&gt;:let @a .= ...&lt;/code&gt;, the
register will change to linewise.&lt;/p&gt;
&lt;p&gt;If you want to get around this, you have a few options. The first uses yanking
to get a newline at the end of your register. In insert mode, type
&lt;code&gt;&amp;lt;C-V&amp;gt;&amp;lt;C-M&amp;gt;&lt;/code&gt;. This inserts a newline character which you can yank into register
&lt;code&gt;a&lt;/code&gt; with &lt;code&gt;"ayl&lt;/code&gt;. Register &lt;code&gt;a&lt;/code&gt; will still be &lt;code&gt;characterwise&lt;/code&gt;, but &lt;code&gt;a&lt;/code&gt; will have
a trailing newline character.&lt;/p&gt;
&lt;p&gt;A second option, which is perhaps a bit hackier, is to not append just a
newline to your register, but a newline plus some other character. For example:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; @&lt;span class="k"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;\n|&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Here the register ends with the pipe character. You could use a space or tab or
any non-newline character. In our PHP example from the previous section, this
technique might have been useful if we wanted each line to begin with a tab
character, for example.&lt;/p&gt;</summary><category term="vim"></category><category term="programming"></category></entry><entry><title>Automatically Focus on Amazon's Search Bar</title><link href="http://buckryan.com/automatically-focus-on-amazons-search-bar.html" rel="alternate"></link><updated>2013-03-07T00:00:00-05:00</updated><author><name>Buck Ryan</name></author><id>tag:buckryan.com,2013-03-07:automatically-focus-on-amazons-search-bar.html</id><summary type="html">&lt;p&gt;Whenever I visit Amazon's homepage, I do so hoping to search for things. I'm
not one to browse around and I'm sure many others are the same. However, I get
annoyed each time this happens because the search bar does not have the focus
when you visit the homepage. After coming across a
&lt;a href="http://news.ycombinator.com/item?id=5333209"&gt;comment&lt;/a&gt; on Hacker News
describing the same problem, I realized I could fix this with a pretty simple
Chrome extension. Check it out
&lt;a href="https://chrome.google.com/webstore/detail/amazon-search-auto-focus/mlblghbllacignpjknjbpbefjmgnbpca"&gt;here&lt;/a&gt;
and read on for a short description of how I put it together.&lt;/p&gt;
&lt;p&gt;About one or two years back, I was interested in making extensions for Chrome,
but never went very far with it. However, the brief foray meant that yesterday,
I knew the basics I would need to make the extension. The most important part
of this is the &lt;a href="http://developer.chrome.com/extensions/manifest.html"&gt;manifest&lt;/a&gt;,
which describes your extension, lists the permissions it needs, files it
contains, and so forth.&lt;/p&gt;
&lt;p&gt;The manifest for this app was really simple:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;manifest_version&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Amazon Search AutoFocus&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Automatically focus on search bar when visiting Amazon&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;permissions&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;http://*.amazon.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;&amp;quot;https://*.amazon.com/&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;quot;content_scripts&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;quot;matches&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;http://*.amazon.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;quot;js&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;script.js&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Most of this is pretty obvious. The documentation on the
&lt;a href="http://developer.chrome.com/extensions/manifest.html#manifest_version"&gt;manifest_version&lt;/a&gt;
indicates that version 1 is deprecate. The version indicated lets Google
manage the extension among users. This number will be used to determine if a
user is on an older version of the extension and it needs to be updated.&lt;/p&gt;
&lt;p&gt;Permissions are bit complicated, as they can include whether the extension
can operate on tabs or windows, have access to sites, etc. For this really
simple app, I only need to indicate that I want access to the amazon sites.&lt;/p&gt;
&lt;p&gt;Finally, the hardest part of it all was figuring out how to get some javascript
to run when I visited Amazon's homepage. Using some Google-foo, I discovered
that &lt;a href="http://developer.chrome.com/extensions/content_scripts.html"&gt;Content Scripts&lt;/a&gt;
are the way to do this. As the documentation says, &lt;code&gt;content scripts run in the
context of web pages&lt;/code&gt;. This means the javascript file specified above
(script.js) will be run when Amazon loads. This is exactly what I wanted!&lt;/p&gt;
&lt;p&gt;So finally I just needed to write the javascript. It turned out to be dead
simple. Here's the only line needed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;document.getElementById(&amp;quot;twotabsearchtextbox&amp;quot;).focus();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I briefly examined Amazon's search box using the Chrome
&lt;a href="https://developers.google.com/chrome-developer-tools/docs/elements"&gt;developer tools&lt;/a&gt;
and I saw that the ID of the search box was &lt;code&gt;twotabsearchtextbox&lt;/code&gt;. So I used
some native javascript functions to set the focus and it was done!&lt;/p&gt;
&lt;p&gt;Hopefully this helps if you want to write your own Chrome extension! If I make
any changes or improvements to this, the updated code will be
&lt;a href="https://bitbucket.org/b_ryan/amazon-autofocus"&gt;on Bitbucket&lt;/a&gt; for your viewing
pleasure.&lt;/p&gt;</summary><category term="chrome"></category><category term="extension"></category><category term="amazon"></category><category term="autofocus"></category><category term="javascript"></category></entry></feed>